{{- /* Make certs generated automatically last 100 years. Why? We're doing this automatically for customers
       who haven't provided their own certificates, meaning they might be blissfully unaware that these certs
       are even in use. If we put it at a "recommended" value like 1 year, there is a reasonable chance that
       a year from when they install, they will not have reissued a new cert, and they will have an outage. That's
       really bad. */ -}}
{{- $apicert := genSelfSignedCert "cnx-api.kube-system.svc" (list ) (list "cnx-api.kube-system.svc") 36500 -}}

{{- if eq .Values.datastore "kubernetes" }}
# This manifest adds the additional Tigera Secure EE components to a cluster
# that has already had the Calico part of Tigera Secure EE deployed.
# - It refers to the calico-config ConfigMap from that file, so if you are
#   not using the provided hosted Calico manifest you must update
#   references to that resource in this file.
# - Optionally update the cnx-apiserver-certs ConfigMap and caBundle in the
#   apiregistration section below to use your TLS certs for secure communication
#   between the Tigera Secure EE API server and Kubernetes API server.
{{- else if eq .Values.datastore "etcd" }}
# This manifest adds the additional Tigera Secure EE components to a cluster
# that has already had the Calico part of Tigera Secure EE deployed.
# - It refers to the calico-config ConfigMap and calico-etcd-secrets Secret
#   from that file, so if you are not using the provided hosted Calico
#   manifest you must update references to those resources in this file.
# - Optionally update the cnx-apiserver-certs ConfigMap and caBundle in the
#   apiregistration section below to use your TLS certs for secure communication
#   between the Tigera Secure EE API server and Kubernetes API server.
{{- end }}

apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: cnx-apiserver-certs
  namespace: kube-system
data:
{{- if include "calico.apiserver.tls" . }}
  apiserver.crt: {{ template "calico.maybeBase64Encode" .Values.apiserver.tls.crt }}
  apiserver.key: {{ template "calico.maybeBase64Encode" .Values.apiserver.tls.key }}
{{- else }}
  apiserver.crt: {{ $apicert.Cert | b64enc }}
  apiserver.key: {{ $apicert.Key | b64enc }}
{{- end }}
---

apiVersion: apiregistration.k8s.io/v1beta1
kind: APIService
metadata:
  name: v3.projectcalico.org
spec:
  group: projectcalico.org
  versionPriority: 200
  groupPriorityMinimum: 200
  service:
    name: cnx-api
    namespace: kube-system
  version: v3
{{- if include "calico.apiserver.tls" . }}
  caBundle: {{ template "calico.maybeBase64Encode" .Values.apiserver.tls.cabundle }}
{{- else }}
  caBundle: {{ $apicert.Cert | b64enc }}
{{- end }}
---

# This ClusterRole is used to control the RBAC mechanism for Calico tiered policy.
# -  If the resources are set to ["networkpolicies","globalnetworkpolicies"], then RBAC for Calico policy has per-tier
#    granularity defined using the "tier.networkpolicies" and "tier.globalnetworkpolicies" pseudo-resource types.
#    This is the default as of v2.3.
# -  If the resources are set to ["tier.networkpolicies","tier.globalnetworkpolicies"], this ensures RBAC for Calico
#    policy is the v2.2 (and earlier) format, where Calico policy RBAC is identical across all tiers that the user can
#    access (i.e. has 'get' access for).
#
# Never include both networkpolicies and tier.networkpolicies and/or globalnetworkpolicies and
# tier.globalnetworkpolicies in the resources list for this ClusterRole since that will grant all users full access to
# Calico policy.
#
# If you are upgrading from CNX v2.2 or earlier:
# - to maintain v2.2 RBAC behavior for tiered Calico policy, modify the resources line below to read:
#        resources: ["tier.networkpolicies","tier.globalnetworkpolicies"]
# - to start using per-tier RBAC for Calico policy resources, prior to upgrading update any Role and ClusterRole
#   resources for your users that reference the projectcalico.org policy resource types networkpolicies or
#   globalnetworkpolicies to also include tier.networkpolicies and tier.globalnetworkpolicies respectively.
#   For example, the resources ["networkpolicies"] would be replaced with ["networkpolicies", "tier.networkpolicies"].
#   Once the upgrade is complete, the Role and ClusterRole definitions can be further updated to provide per-tier
#   granularity of Calico policy RBAC. Refer to the Tigera documentation for details.
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: ee-calico-tiered-policy-passthru
rules:
- apiGroups: ["projectcalico.org"]
{{- if eq .Values.rbac "pre23" }}
  resources: ["tier.networkpolicies","tier.globalnetworkpolicies"]
{{- else }}
  resources: ["networkpolicies","globalnetworkpolicies","stagednetworkpolicies","stagedglobalnetworkpolicies"]
{{- end }}
  verbs: ["*"]

---

kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: ee-calico-tiered-policy-passthru
subjects:
- kind: Group
  name: system:authenticated
  apiGroup: rbac.authorization.k8s.io
- kind: Group
  name: system:unauthenticated
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: ee-calico-tiered-policy-passthru
  apiGroup: rbac.authorization.k8s.io

---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: tigera-tier-getter
rules:
- apiGroups:
  - projectcalico.org
  resources:
  - tiers
  verbs:
  - get

---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tigera-tier-getter
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tigera-tier-getter
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: system:kube-controller-manager

---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: calico:system:auth-delegator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: cnx-apiserver
  namespace: kube-system

---

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: calico-auth-reader
  namespace: kube-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: extension-apiserver-authentication-reader
subjects:
- kind: ServiceAccount
  name: cnx-apiserver
  namespace: kube-system

---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cnx-manager-pip
rules:
- apiGroups: ["projectcalico.org"]
  resources:
    - networksets
    - globalnetworksets
    - globalnetworkpolicies
    - tier.globalnetworkpolicies
    - networkpolicies
    - tier.networkpolicies
    - stagedglobalnetworkpolicies
    - tier.stagedglobalnetworkpolicies
    - stagednetworkpolicies
    - tier.stagednetworkpolicies
    - stagedkubernetesnetworkpolicies
  verbs:
    - list
- apiGroups: ["projectcalico.org"]
  resources:
    - tiers
  verbs:
    - get
    - list
- apiGroups: ["networking.k8s.io"]
  resources:
    - networkpolicies
  verbs:
    - list
    - get
- apiGroups: [""]
  resources:
  - serviceaccounts
  - namespaces
  verbs:
    - list

---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cnx-manager-pip
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cnx-manager-pip
subjects:
- kind: ServiceAccount
  name: cnx-manager
  namespace: calico-monitoring

---

kind: ServiceAccount
apiVersion: v1
metadata:
  name: cnx-apiserver
  namespace: kube-system

---

{{- if eq .Values.datastore "kubernetes" }}
# Give cnx-apiserver ServiceAccount permissions needed for
# accessing various backing CRDs and K8s networkpolicies.
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cnx-apiserver-role
rules:
  - apiGroups: ["extensions","networking.k8s.io",""]
    resources:
      - networkpolicies
      - nodes
      - namespaces
      - pods
      - serviceaccounts
    verbs:
      - get
      - list
      - watch
  - apiGroups: ["crd.projectcalico.org"]
    resources:
      - globalnetworkpolicies
      - stagedglobalnetworkpolicies
      - networkpolicies
      - stagedkubernetesnetworkpolicies
      - stagednetworkpolicies        
      - tiers
      - clusterinformations
      - hostendpoints
      - licensekeys
      - globalalerts
      - globalnetworksets
      - networksets
      - globalthreatfeeds
      - globalreporttypes
      - globalreports
      - bgpconfigurations
      - bgppeers
      - felixconfigurations
      - ippools
      - managedclusters
      - remoteclusterconfigurations
    verbs:
      - "*"

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cnx-apiserver-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cnx-apiserver-role
subjects:
- kind: ServiceAccount
  name: cnx-apiserver
  namespace: kube-system

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tigera-extension-apiserver-auth-access
rules:
  - apiGroups: [""]
    resources:
      - configmaps
    verbs:
      - get
      - list
      - watch
    resourceNames:
      - extension-apiserver-authentication

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tigera-extension-apiserver-auth-access
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tigera-extension-apiserver-auth-access
subjects:
- kind: ServiceAccount
  name: cnx-apiserver
  namespace: kube-system

---
{{- end }}

apiVersion: v1
kind: Service
metadata:
  name: cnx-api
  namespace: kube-system
spec:
  ports:
  - name: apiserver
    port: 443
    protocol: TCP
    targetPort: 5443
  - name: queryserver
    port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    apiserver: "true"

---

# Audit policy for the Tigera Secure EE API Server.
apiVersion: v1
kind: ConfigMap
metadata:
  name: audit-policy-ee
  namespace: kube-system
data:
  config: |-
    apiVersion: audit.k8s.io/v1beta1
    kind: Policy
    rules:
    - level: RequestResponse
      omitStages:
      - RequestReceived
      verbs:
      - create
      - patch
      - update
      - delete
      resources:
      - group: projectcalico.org
        resources:
        - globalnetworkpolicies
        - networkpolicies
        - stagedglobalnetworkpolicies
        - stagednetworkpolicies
        - stagedkubernetesnetworkpolicies
        - globalnetworksets
        - networksets
        - tiers
        - hostendpoints

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: cnx-apiserver
  namespace: kube-system
  labels:
    apiserver: "true"
    k8s-app: cnx-apiserver
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      apiserver: "true"
  template:
    metadata:
      name: cnx-apiserver
      namespace: kube-system
      labels:
        apiserver: "true"
        k8s-app: cnx-apiserver
    spec:
      nodeSelector:
        beta.kubernetes.io/os: linux
{{ if .Values.controlPlaneNodeSelector }}
{{- toYaml .Values.controlPlaneNodeSelector | indent 8 }}
{{- end }}
      serviceAccountName: cnx-apiserver
      tolerations:
        - key: node-role.kubernetes.io/master
          effect: NoSchedule
{{- if .Values.imagePullSecrets }}
      imagePullSecrets:
{{- range $key, $value := .Values.imagePullSecrets }}
        - name: {{ $key }}
{{- end }}
{{- end }}
      containers:
      - name: cnx-apiserver
        image: {{ join ":" (list .Values.apiserver.image .Values.apiserver.tag) }}
{{ tuple .Values.apiserver.resources | include "calico.resourceLimits" | indent 8 -}}
        args:
          - "--secure-port=5443"
{{- if eq .Values.platform "eks" }}
          # API servers normally look for authentication information in the configmap
          # extension-apiserver-authentication.  EKS doesn't include all the values that
          # an API server would normally expect, so we disable this lookup. The only
          # value we actually need from this configmap is requestheader-client-ca-file
          # which *is* present, so we just volume-mount the config map and set it via
          # the next flag.
          - "--authentication-skip-lookup=true"
          # This CA is the root of trust for the certificate that the main Kube API server
          # uses when it proxies requests *to* this extension API server.  This is how we
          # know we are getting requests from the real API server and can believe that it
          # has already handled authenticating the end user.
          - "--requestheader-client-ca-file=/code/certificates/requestheader-client-ca-file"
{{- end }}
          - "--audit-policy-file=/etc/tigera/audit/policy.conf"
          - "--audit-log-path=/var/log/calico/audit/tsee-audit.log"
        env:
{{- if .Values.apiserver.env }}
{{ toYaml .Values.apiserver.env | indent 10 }}
{{- end }}
{{- if eq .Values.datastore "etcd" }}
          - name: ETCD_ENDPOINTS
            valueFrom:
              configMapKeyRef:
                name: calico-config
                key: etcd_endpoints
          - name: DATASTORE_TYPE
            value: "etcdv3"
          # Location of the CA certificate for etcd.
          - name: ETCD_CA_CERT_FILE
            valueFrom:
              configMapKeyRef:
                name: calico-config
                key: etcd_ca
          # Location of the client key for etcd.
          - name: ETCD_KEY_FILE
            valueFrom:
              configMapKeyRef:
                name: calico-config
                key: etcd_key
          # Location of the client certificate for etcd.
          - name: ETCD_CERT_FILE
            valueFrom:
              configMapKeyRef:
                name: calico-config
                key: etcd_cert
        volumeMounts:
          - mountPath: /calico-secrets
            name: etcd-certs
{{- else if eq .Values.datastore "kubernetes" }}
          - name: DATASTORE_TYPE
            value: "kubernetes"
        volumeMounts:
{{- end }}
          - mountPath: /var/log/calico/audit
            name: var-log-calico-audit
          - mountPath: /etc/tigera/audit
            name: audit-policy-ee
{{- if eq .Values.platform "eks" }}
          - mountPath: /code/certificates/requestheader-client-ca-file
            name: requestheader-client-ca-file
            subPath: requestheader-client-ca-file
{{- end }}
          - mountPath: /code/apiserver.local.config/certificates
            name: apiserver-certs
        livenessProbe:
          httpGet:
            path: /version
            port: 5443
            scheme: HTTPS
          initialDelaySeconds: 90
          periodSeconds: 10
{{- if .Values.apiserver.runAsPrivileged }}
        securityContext:
          privileged: true
{{- end }}
      - name: cnx-queryserver
        image: {{ join ":" (list .Values.queryserver.image .Values.queryserver.tag) }}
{{ tuple .Values.queryserver.resources | include "calico.resourceLimits" | indent 8 -}}
        env:
          # Set queryserver logging to "info"
          - name: LOGLEVEL
            value: "info"
{{- if eq .Values.datastore "etcd" }}
          - name: ETCD_ENDPOINTS
            valueFrom:
              configMapKeyRef:
                name: calico-config
                key: etcd_endpoints
          - name: DATASTORE_TYPE
            value: "etcdv3"
          # If you're using TLS enabled etcd uncomment the following.
          # Location of the CA certificate for etcd.
          - name: ETCD_CA_CERT_FILE
            valueFrom:
              configMapKeyRef:
                name: calico-config
                key: etcd_ca
          # Location of the client key for etcd.
          - name: ETCD_KEY_FILE
            valueFrom:
              configMapKeyRef:
                name: calico-config
                key: etcd_key
          # Location of the client certificate for etcd.
          - name: ETCD_CERT_FILE
            valueFrom:
              configMapKeyRef:
                name: calico-config
                key: etcd_cert
          # Sets Default Security Groups if tigera-aws-config exists
          - name: TIGERA_DEFAULT_SECURITY_GROUPS
            valueFrom:
              configMapKeyRef:
                name: tigera-aws-config
                key: default_sgs
                optional: true
          # Sets Pod Security Group if tigera-aws-config exists
          - name: TIGERA_POD_SECURITY_GROUP
            valueFrom:
              configMapKeyRef:
                name: tigera-aws-config
                key: pod_sg
                optional: true
        volumeMounts:
          - mountPath: /calico-secrets
            name: etcd-certs
{{- else if eq .Values.datastore "kubernetes" }}
          - name: DATASTORE_TYPE
            value: "kubernetes"
          # Sets Default Security Groups if tigera-aws-config exists
          - name: TIGERA_DEFAULT_SECURITY_GROUPS
            valueFrom:
              configMapKeyRef:
                name: tigera-aws-config
                key: default_sgs
                optional: true
          # Sets Pod Security Group if tigera-aws-config exists
          - name: TIGERA_POD_SECURITY_GROUP
            valueFrom:
              configMapKeyRef:
                name: tigera-aws-config
                key: pod_sg
                optional: true
{{- end }}
{{- if .Values.queryserver.env }}
{{ toYaml .Values.queryserver.env | indent 10 }}
{{- end }}
        livenessProbe:
          httpGet:
            path: /version
            port: 8080
            scheme: HTTPS
          initialDelaySeconds: 90
          periodSeconds: 10
        securityContext:
          runAsNonRoot: true
          allowPrivilegeEscalation: false
      volumes:
        # Volume for audit logs output
        - name: var-log-calico-audit
          hostPath:
            path: /var/log/calico/audit
            type: DirectoryOrCreate
        - name: audit-policy-ee
          configMap:
            name: audit-policy-ee
            items:
            - key: config
              path: policy.conf
{{- if eq .Values.datastore "etcd" }}
        # Mount in the etcd TLS secrets with mode 400.
        # See https://kubernetes.io/docs/concepts/configuration/secret/
        - name: etcd-certs
          secret:
            secretName: calico-etcd-secrets
{{- end }}
{{- if eq .Values.platform "eks" }}
        - name: requestheader-client-ca-file
          configMap:
            name: extension-apiserver-authentication
{{- end }}
        - name: apiserver-certs
          secret:
            secretName: cnx-apiserver-certs
