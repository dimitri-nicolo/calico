// Copyright (c) 2023 Tigera, Inc. All rights reserved.

//go:build fvtests

package fv_test

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	bapi "github.com/projectcalico/calico/linseed/pkg/backend/api"
)

// Token to use for HTTP requests against Linseed.
var token []byte

// setupLinseedFV performs additional setup for Linseed FV tests.
func setupLinseedFV(t *testing.T, idx bapi.Index) func() {
	// Get the token to use in HTTP authorization header.
	var err error
	token, err = os.ReadFile(TokenPath)
	require.NoError(t, err)
	return func() {
	}
}

func TestFV_Linseed(t *testing.T) {
	addr := "localhost:8443"
	healthAddr := "localhost:8080"

	tests := []struct {
		name           string
		path           string
		method         string
		headers        map[string]string
		body           string
		wantStatusCode int
		wantBody       string
		checkBody      func(trimmedResBody string)
	}{
		{
			name: "should return 200 for /version",
			path: "/version", method: "GET", wantStatusCode: 200,
			checkBody: func(trimmedResBody string) {
				var buildInfo struct {
					BuildDate    string `json:"buildDate"`
					GitCommit    string `json:"gitCommit"`
					GitTag       string `json:"gitTag"`
					BuildVersion string `json:"buildVersion"`
				}
				err := json.Unmarshal([]byte(trimmedResBody), &buildInfo)
				assert.Nil(t, err)
				assert.NotEmpty(t, buildInfo.BuildDate)
				assert.NotEmpty(t, buildInfo.GitCommit)
				assert.NotEmpty(t, buildInfo.GitTag)
				assert.NotEmpty(t, buildInfo.BuildVersion)
			},
		},
		{
			name: "should return 404 for /",
			path: "/", method: "GET", wantStatusCode: 404, wantBody: `{"Status":404,"Msg":"No matching authz options for GET /"}`,
		},
		{
			name: "should return 404 for /foo",
			path: "/foo", method: "GET", wantStatusCode: 404, wantBody: `{"Status":404,"Msg":"No matching authz options for GET /foo"}`,
		},
		{
			name: "should return 404 for /api/v1/flows/foo",
			path: "/api/v1/flows/foo", method: "GET", wantStatusCode: 404, wantBody: `{"Status":404,"Msg":"No matching authz options for GET /api/v1/flows/foo"}`,
		},
		{
			name: "should return 404 for DELETE /version",
			path: "/version", method: "DELETE", wantStatusCode: 404, wantBody: `{"Status":404,"Msg":"No matching authz options for DELETE /version"}`,
		},
		{
			name: "should return 415 unsupported content type for /api/v1/flows",
			path: "/api/v1/flows/", method: "POST",
			headers: contentType("text/plain"), body: "{}", wantStatusCode: 415, wantBody: "",
		},
		{
			name: "should return 415 unsupported content type for /api/v1/flows/logs/bulk",
			path: "/api/v1/flows/logs/bulk", method: "POST",
			headers: contentType("text/plain"), body: "{}", wantStatusCode: 415, wantBody: "",
		},
	}

	for _, tt := range tests {
		RunFlowLogTest(t, tt.name, func(t *testing.T, idx bapi.Index) {
			defer setupLinseedFV(t, idx)()

			client := mTLSClient(t)
			httpReqSpec := noBodyHTTPReqSpec(tt.method, fmt.Sprintf("https://%s%s", addr, tt.path), clusterInfo.Tenant, clusterInfo.Cluster, token)
			httpReqSpec.AddHeaders(tt.headers)
			httpReqSpec.SetBody(tt.body)
			res, resBody := doRequest(t, client, httpReqSpec)

			assert.Equal(t, tt.wantStatusCode, res.StatusCode)
			trimmedResBody := strings.Trim(string(resBody), "\n")
			if tt.checkBody != nil {
				// Custom check of the body.
				tt.checkBody(trimmedResBody)
			} else {
				// Default check of the body.
				assert.Equal(t, tt.wantBody, trimmedResBody)
			}
		})
	}

	RunFlowLogTest(t, "should deny any HTTP connection", func(t *testing.T, idx bapi.Index) {
		defer setupLinseedFV(t, idx)()

		client := &http.Client{}
		res, resBody := doRequest(t, client, noBodyHTTPReqSpec("GET", fmt.Sprintf("http://%s/", addr), clusterInfo.Tenant, clusterInfo.Cluster, nil))

		assert.Equal(t, http.StatusBadRequest, res.StatusCode)
		assert.Equal(t, "Client sent an HTTP request to an HTTPS server.", strings.Trim(string(resBody), "\n"))
	})

	RunFlowLogTest(t, "should deny any TLS connection", func(t *testing.T, idx bapi.Index) {
		defer setupLinseedFV(t, idx)()

		client := tlsClient(t)
		req, err := http.NewRequest("GET", fmt.Sprintf("https://%s/", addr), nil)
		require.NoError(t, err)
		_, err = client.Do(req)
		require.Error(t, err)
		require.Contains(t, err.Error(), "remote error: tls: certificate required")
	})

	RunFlowLogTest(t, "should deny mTLS connections that use a certificate generated by a different CA", func(t *testing.T, idx bapi.Index) {
		defer setupLinseedFV(t, idx)()

		// Create the certificates
		ca, caKey := mustCreateCAKeyPair(t)
		caBytes := signAndEncodeCert(t, ca, caKey, ca, caKey)
		cert, key := mustCreateClientKeyPair(t)
		certBytes := signAndEncodeCert(t, ca, caKey, cert, key)
		keyBytes := encodeKey(t, key)

		client := mTLSClientWithCerts(certPool(caBytes), mustGetTLSKeyPair(t, certBytes, keyBytes))

		req, err := http.NewRequest("GET", fmt.Sprintf("https://%s/", addr), nil)
		require.NoError(t, err)
		_, err = client.Do(req)
		require.Error(t, err)
		require.Contains(t, err.Error(), "x509: certificate signed by unknown authority")
	})

	RunFlowLogTest(t, "should be ready", func(t *testing.T, idx bapi.Index) {
		defer setupLinseedFV(t, idx)()

		client := mTLSClient(t)
		httpReqSpec := noBodyHTTPReqSpec("GET", fmt.Sprintf("http://%s/readiness", healthAddr), clusterInfo.Tenant, clusterInfo.Cluster, token)
		res, _ := doRequest(t, client, httpReqSpec)
		assert.Equal(t, http.StatusOK, res.StatusCode)
	})

	RunFlowLogTest(t, "should be live", func(t *testing.T, idx bapi.Index) {
		defer setupLinseedFV(t, idx)()

		client := mTLSClient(t)
		httpReqSpec := noBodyHTTPReqSpec("GET", fmt.Sprintf("http://%s/liveness", healthAddr), clusterInfo.Tenant, clusterInfo.Cluster, token)
		res, _ := doRequest(t, client, httpReqSpec)
		assert.Equal(t, http.StatusOK, res.StatusCode)
	})
}

func contentType(value string) map[string]string {
	return map[string]string{"content-type": value}
}
